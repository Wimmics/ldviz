/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
export namespace Components {
    interface DashboardAnnotation {
        "height": number;
        "width": number;
    }
    interface MgeAnnotation {
        /**
          * The parent dashboard
         */
        "_dashboard": any;
        "_view": any;
        "disabled": boolean;
        "formAnnotation": any;
        "height": number;
        "idannotation": any;
        "initComponent": string;
        "parents": any[];
        "setBox": (_: any) => Promise<any>;
        "width": number;
    }
    interface MgeBarchart {
        /**
          * represents the panel associated with the graph
         */
        "_barPanel": any;
        /**
          * Contains the indexes of the attributes that can be configured in the graph
         */
        "_cfgIndexAttr": any;
        /**
          * colors for the different types
         */
        "_colorsBars": any;
        /**
          * keeps data on the different types of documents (attributes)
         */
        "_documentTypes": any;
        /**
          * Group representing Histogram
         */
        "_grpHistogram": any;
        /**
          * keeps the count of documents per year and type
         */
        "_histogramData": any;
        /**
          * (calculated) radius of the circle where the centroid is inserted
         */
        "_innerRadius": any;
        /**
          * (calculated) distance occupied by the bars
         */
        "_maxHeightBar": any;
        /**
          * Number of types of documents in the base
         */
        "_nbOfTypesDoc": any;
        /**
          * (calculated) Outernal circle radius where the graph is drawn
         */
        "_outerRadius": any;
        /**
          * Indirect ordering vector
         */
        "_vOrder": any;
        "acSortExecAttribute": () => Promise<void>;
        "acSortExecText": () => Promise<void>;
        "dataVisToNode": (index: any) => Promise<any>;
        /**
          * The dataset name being used
         */
        "datasetName": string;
        "getSourceObject": () => Promise<any>;
        /**
          * represents the height of the Histogram chart
         */
        "height": number;
        /**
          * Set box size for the chart includes the content input is a object includes height and width If no arguments, It will return the value of box
         */
        "setBox": (_: any) => Promise<any>;
        /**
          * This function is to set the data to the chart If no arguments, It will return the value of data
         */
        "setData": (_: any, globalData: any, secondNode: any, isFromEdge?: boolean, isFromCluster?: boolean, isFromHC?: boolean) => Promise<any>;
        "setIndexAttrBar": (_: any) => Promise<any>;
        /**
          * This function is required in all techniques It is called internally in conectChart
         */
        "setPanel": (_: any) => Promise<any>;
        "setpMaxHeightBar": (_: any) => Promise<any>;
        /**
          * represents the width of the Histogram chart
         */
        "width": number;
    }
    interface MgeClustervis {
        /**
          * _angleToWidth  Calculates the sector width from the angle and a radius E: width, radius S: angle in degrees
         */
        "_angleToWidth": (angle: any, radius: any) => Promise<number>;
        /**
          * _calcCoordinates  Calculates the coordinates of the leaf nodes
         */
        "_calcCoordinates": (dataNodes: any) => Promise<void>;
        /**
          * _calcGeometry  Calculates all geometric parameters for ClusterVis display
         */
        "_calcGeometry": (data: any) => Promise<void>;
        /**
          * Represents the panel associated with the graphic
         */
        "_clusterVisPanel": any;
        /**
          * Generator of splines that makes up the edges
         */
        "_drawLine": any;
        /**
          * _getEdges  Generates a vector with the list of edges in the format: [ {source:Object, target: Object},...]
         */
        "_getEdges": (dados: any, nodes: any) => Promise<any[]>;
        /**
          * _getTree  Generates a tree in the format { id:..., chidren[] }
         */
        "_getTree": (heightTree: any, dados: any, degree: any, vOrder: any) => Promise<any>;
        /**
          * Selection that contains all groups that store the bars
         */
        "_grpBars": any;
        /**
          * Group representing ClusterVis
         */
        "_grpCluster": any;
        /**
          * Selection that contains all groups that store the links
         */
        "_grpLinks": any;
        /**
          * Selection that contains all groups that store the rings
         */
        "_grpRings": any;
        /**
          * (calculated) Internal circle radius where the graph is drawn
         */
        "_innerRadius": number;
        /**
          * Selection that contains the links
         */
        "_links": any;
        /**
          * (calculated) Outernal circle radius where the graph is drawn
         */
        "_outerRadius": number;
        /**
          * Indicates that the same scale should be used for all bars
         */
        "_sameScale": boolean;
        "_updateMaxRings": () => Promise<void>;
        /**
          * _widthToAngle  Calculates the angle of the occupied sector by a width E: width, radius S: angle in degrees
         */
        "_widthToAngle": (width: any, radius: any) => Promise<number>;
        /**
          * Coordinate x of the center of the cluster
         */
        "_xClusterCenter": number;
        /**
          * Coordinate y of the center of the cluster
         */
        "_yClusterCenter": number;
        "acAlteraAnel": (indexAnel: any, indexAttr: any) => Promise<void>;
        "acSameScale": (checked: any) => Promise<void>;
        "acSortExec": (_: any) => Promise<void>;
        "addAttribute": (_indexAttr: any, _typeAttr: any) => Promise<void>;
        /**
          * The initial function to create all of elements in the cluster chart In this function, it will set Geometric attributes of the graph create actions on graph and manage all of the interaction on the graph
         */
        "addClusterChart": (idDiv: any, divTag: any) => Promise<void>;
        "alteraAttribute": (_indexAnel: any, _indexAttr: any, _typeAttr: any) => Promise<void>;
        /**
          * The dataset name being used
         */
        "datasetName": string;
        /**
          * represents the height of the Cluster chart
         */
        "height": number;
        "indexAttrSort": (_: any) => Promise<number>;
        "obtemRings": () => Promise<any[]>;
        "removeAnelExterno": () => Promise<void>;
        "setBox": (_: any) => Promise<any>;
        /**
          * This function is to set the data to the chart If no arguments, It will return the value of data
         */
        "setData": (_: any, globalData: any) => Promise<any>;
        /**
          * This function is required in all techniques It is called internally in conectChart
         */
        "setPanel": (_: any) => Promise<any>;
        /**
          * Set value of Percentage relative to graph width for _innerRadius calculation If no arguments, It will return the value of pInnerRadius
         */
        "setpInnerRadius": (_: any) => Promise<any>;
        /**
          * Set value of Percentage relative to graph width for _OuterRadius calculation If no arguments, It will return the value of pOuterRadius
         */
        "setpOuterRadius": (_: any) => Promise<any>;
        /**
          * represents the width of the Cluster chart
         */
        "width": number;
    }
    interface MgeDashboard {
        /**
          * This function is to create links from parent window and the children windown It includes connection and line links
         */
        "_addLink": (viewParent: any, viewChild: any) => Promise<{ line: any; conect: any; visible: boolean; }>;
        "_addLinkAnnotation": (viewParents: any, viewChild: any) => Promise<{ lines: any[]; conect: any; visible: boolean; }>;
        "_addcube": (viewChild: any) => Promise<{ lines: any[]; conect: any; visible: boolean; }>;
        "_annotationChart": any;
        /**
          * Area of dashboard for interacting
         */
        "_dashboardArea": any;
        /**
          * Drag connection of views
         */
        "_dragConect": any;
        /**
          * Stores the graph that contains history
         */
        "_historyChart": any;
        "_historydata": any;
        /**
          * First view of the dashboard. It depends on the value of initComponent to define what visualization technique or initial query is the first view to be initialized with.
         */
        "_initView": any;
        /**
          * Stores the tree of connections between views
         */
        "_treeCharts": any;
        /**
          * This method adds a new view to the dashboard and update the tree history with information regarding the new view.
         */
        "addChart": (idParent: any, objChart: any) => Promise<void>;
        /**
          * This method hides the given view from the dashboard (CSS - display:none) and update the status of this view in the history panel (mge-history).
         */
        "closeView": (view: any) => Promise<void>;
        /**
          * The dataset name being used
         */
        "datasetName": string;
        "getChart": (idChart: any, isAnnotation?: boolean) => Promise<any>;
        /**
          * Get all of params from list pre-defined query to save in global variables. Global variable in this case is a set of public variables that all components in the application can use)
         */
        "init": (locals: any) => Promise<void>;
        /**
          * type of visualization which want to create in inital point
         */
        "initComponent": any;
        /**
          * This function is to refresh the status of the links and connection
         */
        "refreshLinks": () => Promise<void>;
        "refreshSvg": () => Promise<void>;
        /**
          * This function is to clear all of elements in dashboard It will be run when clicking re-run for new query in initial point
         */
        "resetDashboard": () => Promise<void>;
        "setDashboard": () => Promise<void>;
        /**
          * This function allows to store new dataset which got from mge-query to a global variable
         */
        "setData": (_: any) => Promise<void>;
        /**
          * This function is to show the view includes chart It will be updated depend on the status of the view in tree history
         */
        "showView": (view: any) => Promise<void>;
        /**
          * x-coordinate (The horizontal value in a pair of coordinates) of the dashboard
         */
        "x": number;
        /**
          * y-coordinate (The vertical value in a pair of coordinates) of the dashboard
         */
        "y": number;
    }
    interface MgeGlyphMatrix {
        /**
          * _calcHeightCell  Calculate cell height/width. So is the comment bar
         */
        "_calcHeightCell": () => Promise<any>;
        /**
          * _calcVisibleLines  Determines limits for visible lines
         */
        "_calcVisibleLines": () => Promise<void>;
        /**
          * Scale is used to determine the coordinates of cells and legend elements
         */
        "_cellCoordScale": any;
        /**
          * keeps data on the different types of documents (attributes)
         */
        "_cellGlyph": any;
        /**
          * Listener of legends
         */
        "_dragListenerL": any;
        /**
          * Listener of Matrix
         */
        "_dragListenerM": any;
        /**
          * Select with all groups from left side legend bar
         */
        "_grpBarsLL": any;
        /**
          * Select with all groups from top side legend bar
         */
        "_grpBarsTL": any;
        /**
          * Select with left side legend bar
         */
        "_grpLeftLegend": any;
        /**
          * Contains lines with cells in each line
         */
        "_grpLines": any;
        /**
          * Select with matrix chart
         */
        "_grpMatrix": any;
        /**
          * keeps data on the different types of documents (attributes)
         */
        "_grpMatrixGlyph": any;
        /**
          * The group represents the matrix overview
         */
        "_grpOverview": any;
        /**
          * Select with top side legend bar
         */
        "_grpTopLegend": any;
        /**
          * Left legend clipping area id
         */
        "_idClipLeft": any;
        /**
          * Matrix clipping area id
         */
        "_idClipMatrix": any;
        /**
          * Top legend clipping area id
         */
        "_idClipTop": any;
        /**
          * The index of the attribute will be printed in the legend (node)
         */
        "_indexAttrLegend": number;
        /**
          * Attribute index used for sorting
         */
        "_indexAttrSort": number;
        /**
          * _limCoord  Limit the coordinate value
         */
        "_limCoord": (coord: any) => Promise<any>;
        /**
          * Group represents the entire chart
         */
        "_matrixGlyphPanel": any;
        /**
          * Matrix area height (calculated)
         */
        "_matrixHeight": number;
        /**
          * Matrix area width (calculated)
         */
        "_matrixWidth": number;
        /**
          * _onMouseOverNode
         */
        "_onMouseEnterNode": (event: any, d: any) => Promise<void>;
        /**
          * _onMouseOutNode
         */
        "_onMouseLeaveNode": (event: any, d: any) => Promise<void>;
        /**
          * Scale is used to set the coordinates of the overview cursor
         */
        "_overviewScale": any;
        /**
          * Indirect ordering vector
         */
        "_vOrder": any;
        "acChangeAttrLegend": (_: any) => Promise<void>;
        "acChangeVisibleLines": (qtLines: any) => Promise<void>;
        "acSortExec": (_: any) => Promise<void>;
        /**
          * The initial function to create all of elements in the Matrix Glyph chart In this function, it will set Geometric attributes of the graph create actions on graph and manage all of the interaction on the graph
         */
        "addMatrixGlyph": (idDiv: any, divTag: any) => Promise<void>;
        "cellColorsMap": (colors: any) => Promise<void>;
        /**
          * The dataset name being used
         */
        "datasetName": string;
        "debug": () => Promise<void>;
        "getMaxVisibleLines": () => Promise<number>;
        "getMinVisibleLines": () => Promise<number>;
        "getVisibleLines": () => Promise<number>;
        "glyph": (_: any) => Promise<any>;
        /**
          * represents the height of the matrix chart
         */
        "height": number;
        "indexAttrCellColor": (_: any) => Promise<number>;
        "indexAttrLegend": (_: any) => Promise<number>;
        "indexAttrSort": (_: any) => Promise<number>;
        "pFontHeight": (_: any) => Promise<any>;
        "pLegendWidth": (_: any) => Promise<any>;
        /**
          * Set box size for the chart includes the content input is a object includes height and width If no arguments, It will return the value of box
         */
        "setBox": (_: any) => Promise<any>;
        /**
          * This function is to set the data to the chart If no arguments, It will return the value of data
         */
        "setData": (_: any, globalData: any) => Promise<any>;
        /**
          * This function is required in all techniques It is called internally in conectChart
         */
        "setPanel": (_: any) => Promise<any>;
        "setTTMatrixCell": (_: any) => Promise<void>;
        /**
          * represents the width of the matrix chart
         */
        "width": number;
    }
    interface MgeHeader {
        "data": any[];
        "height": number;
        "setData": (_: any) => Promise<void>;
        "width": number;
    }
    interface MgeHistory {
        /**
          * The parent dashboard
         */
        "_dashboard": any;
        /**
          * Group representing history tree
         */
        "_grpHistory": any;
        /**
          * Group representing nodes in the tree
         */
        "_grpNodes": any;
        "_historydata": any[];
        "_htdata": any;
        /**
          * Distance from the text to the left coordinate of the node
         */
        "_leftText": number;
        /**
          * Margin css of the node
         */
        "_nodeMargin": number;
        /**
          * Space height for each node without the margins
         */
        "_nodoHeight": number;
        /**
          * The height symbol
         */
        "_rectHeight": number;
        /**
          * The tree layout to stored tree data
         */
        "_treeLayout": any;
        /**
          * Vector with objects of all nodes
         */
        "_vNodes": any[];
        /**
          * The initial function to create all of elements in the history treechart In this function, it will set Geometric attributes of the graph create actions on graph and manage all of the interaction on the graph
         */
        "addHistoryTreeChart": (idDiv: any, divTag: any) => Promise<void>;
        /**
          * represents the height of the history panel
         */
        "height": number;
        /**
          * Represents the panel associated with the graphic
         */
        "historyTreePanel": any;
        /**
          * Set box size for the chart includes the content input is a object includes height and width If no arguments, It will return the value of box
         */
        "setBox": (_: any) => Promise<any>;
        /**
          * This function is to set the data to the chart If no arguments, It will return the value of data
         */
        "setData": (_: any) => Promise<any>;
        /**
          * This function is to set the data to the tree history data
         */
        "setTree": (newTree: any) => Promise<void>;
        "typeVis": string;
        /**
          * represents the width of the history panel
         */
        "width": number;
    }
    interface MgeIris {
        /**
          * Contains the indexes of the attributes that can be configured in the graph
         */
        "_cfgIndexAttr": any;
        /**
          * colors for the different types
         */
        "_colorsBars": any;
        /**
          * Vector of visible data. Points to the elements of model.data
         */
        "_dataVis": any;
        /**
          * Contains the attribute of the fish eye area
         */
        "_fishEyeArea": any;
        /**
          * Contains the attribute of the focused area
         */
        "_focusArea": any;
        /**
          * _getTheRightOrder  Returns the order in which we need to display the types of documents
          * @param i
          * @returns 
          * @private
         */
        "_getTheRightOrder": (i: any) => Promise<any>;
        /**
          * Selection that contains all groups of bars
         */
        "_grpBars": any;
        /**
          * Group representing IRIS
         */
        "_grpIris": any;
        /**
          * Contains the attribute of the hidden area
         */
        "_hiddenArea": any;
        /**
          * Index in the "dataVis" vector where the first element of the data vector is located
         */
        "_indexFirstData": any;
        /**
          * (calculated) radius of the circle where the centroid is inserted
         */
        "_innerRadius": any;
        /**
          * The dataset name being used
         */
        "_irisPanel": any;
        /**
          * (calculated) distance occupied by the bars
         */
        "_maxHeightBar": any;
        /**
          * Contains the attribute of the minimum area
         */
        "_minArea": any;
        /**
          * number of types of documents in the base
         */
        "_nbOfTypesDoc": any;
        /**
          * Maximum number of the bars
         */
        "_numMaxBars": any;
        /**
          * Total number of the bars
         */
        "_numTotalBars": any;
        /**
          * The orders of typesDocs
         */
        "_orders": any;
        /**
          * (calculated) Outernal circle radius where the graph is drawn
         */
        "_outerRadius": any;
        /**
          * Percentage of center displacement
         */
        "_pDesloc": any;
        /**
          * Indirect ordering vector
         */
        "_vOrder": any;
        "acSortExecAttribute": (ascending: any) => Promise<void>;
        "acSortExecText": () => Promise<void>;
        "addIrisChart": (idDiv: any, divTag: any) => Promise<void>;
        "dataVisToNode": (index: any) => Promise<any>;
        /**
          * The dataset name being used
         */
        "datasetName": string;
        "getSourceObject": () => Promise<any>;
        "getVOrder": () => Promise<any>;
        /**
          * represents the height of the Iris chart
         */
        "height": number;
        "putBarsOnIris": () => Promise<void>;
        /**
          * Set box size for the chart includes the content input is a object includes height and width If no arguments, It will return the value of box
         */
        "setBox": (_: any) => Promise<any>;
        /**
          * Configure the data that will be printed in the centroid and the text of the bar (Label only)
         */
        "setConfigCentroid": (titulo: any, tituloGrau: any, textoBarra: any) => Promise<void>;
        "setData": (_: any, globalData: any) => Promise<any>;
        "setIndexAttrBar": (_: any) => Promise<any>;
        /**
          * This function is required in all techniques It is called internally in conectChart
         */
        "setPanel": (_: any) => Promise<any>;
        /**
          * Set value of Percentage relative to graph width for _innerRadius calculation If no arguments, It will return the value of pInnerRadius
         */
        "setpInnerRadius": (_: any) => Promise<any>;
        "setpMaxHeightBar": (_: any) => Promise<any>;
        /**
          * Set value of Percentage relative to graph width for _OuterRadius calculation If no arguments, It will return the value of pOuterRadius
         */
        "setpOuterRadius": (_: any) => Promise<any>;
        "updateTextSize": () => Promise<void>;
        /**
          * represents the width of the Iris chart
         */
        "width": number;
    }
    interface MgeListing {
        /**
          * Colors for the different types
         */
        "_colorsRect": any;
        /**
          * List of items in the data
         */
        "_data": any;
        /**
          * Selection that contains all groups of bars
         */
        "_grpPapers": any;
        /**
          * Group representing IRIS
         */
        "_grpPapersList": any;
        /**
          * Maximum length of title
         */
        "_maxLenghtTitleIndex": number;
        /**
          * Maximum length of names
         */
        "_maxNamesLenght": number;
        /**
          * Selection that contains the names of the members of a cluster
         */
        "_names": any;
        /**
          * represents the panel associated with the graph
         */
        "_papersListPanel": any;
        "dataVisToNode": (index: any) => Promise<any>;
        /**
          * The dataset name being used
         */
        "datasetName": string;
        /**
          * represents the height of the paper's list chart
         */
        "height": number;
        /**
          * Set box size for the chart includes the content input is a object includes height and width If no arguments, It will return the value of box
         */
        "setBox": (_: any) => Promise<any>;
        /**
          * This function is to set the data to the listing papers chart If no arguments, It will return the value of data
         */
        "setData": (_: any, globalData: any, secondNode: any, isFromEdge?: boolean, isFromCluster?: boolean, isFromHC?: boolean) => Promise<any>;
        /**
          * represents the width of the paper's list chart
         */
        "width": number;
    }
    interface MgeNodelink {
        /**
          * The group represents the entire graphic
         */
        "_grpNodeEdge": any;
        /**
          * Represents the legend associated with the graphic
         */
        "_nodeEdgeLegend": any;
        /**
          * Represents the panel associated with the graphic
         */
        "_nodeEdgePanel": any;
        "_view": any;
        "acChangeAttrSize": (value: any) => Promise<void>;
        /**
          * This function will change the value of charge on force layout. This function will be called when adjust Charge slider in filter panel
         */
        "acChangeCharge": (value: any) => Promise<void>;
        /**
          * This function will change the value of gravity on force layout. This function will be called when adjust Gravity slider in filter panel
         */
        "acChangeGravity": (value: any) => Promise<void>;
        /**
          * This function will change the value of links distance on force layout. This function will be called when adjust LinkDistance slider in filter panel
         */
        "acChangeLinkDistance": (value: any) => Promise<void>;
        /**
          * This function will hightlight node and all related links by name of selected node. This function will be called when used text search in filter panel
         */
        "acSelectByName": (nome: any) => Promise<void>;
        /**
          * This function will hightlight all nodes in a cluster. This function will be called when used text search in filter panel
         */
        "acSelectByNameCluster": (nomeCluster: any) => Promise<void>;
        "addNodeLinkChart": (idDiv: any, divTag: any) => Promise<void>;
        /**
          * The dataset name being used
         */
        "datasetName": string;
        /**
          * This function will get the `charge` attribute of force layout in node-links chart
         */
        "getCharge": () => Promise<any>;
        /**
          * This function will get the `gravity` attribute of force layout in node-links chart
         */
        "getGravity": () => Promise<any>;
        /**
          * This function will get the `distance` attribute of links in force layout in node-links chart
         */
        "getLinkDistance": () => Promise<any>;
        /**
          * This function will get the total number of edges
         */
        "getQtEdges": () => Promise<any>;
        /**
          * This function will get the total number of nodes
         */
        "getQtNodes": () => Promise<any>;
        /**
          * represents the height of the nodelinks chart
         */
        "height": number;
        /**
          * Changes the attribute that will be used to map the size
         */
        "indexAttrSize": (_: any) => Promise<any>;
        /**
          * This function will remove hightlight effect on all of nodes and links. This function will be called when clear text inside text search
         */
        "resetHighSearch": () => Promise<void>;
        "setBox": (_: any) => Promise<any>;
        "setData": (_: any, globalData: any) => Promise<any>;
        "setLegend": (_: any) => Promise<any>;
        "setPanel": (_: any) => Promise<any>;
        /**
          * represents the width of the nodelinks chart
         */
        "width": number;
    }
    interface MgePanel {
        /**
          * Represents the visualization technique which have same view with this setting panel
         */
        "_chart": any;
        "_divSlider": any;
        /**
          * Represents the div includes cloned html from template
         */
        "_filter": any;
        /**
          * ID of the panel that generated from id of view
         */
        "_idPanel": any;
        /**
          * Text search input (of `mge-nodelinks`)
         */
        "_searchAutocomplete": any;
        "_selectLegend": any;
        "_selectNodeSize": any;
        /**
          * Represents the select input for order of Iris(`mge-iris`) setting panel and  histogram(mge-barchart) setting panel
         */
        "_selectOrder": any;
        /**
          * Slider to adjust linkDistance (of `mge-nodelinks`)
         */
        "_sliderCharge": any;
        /**
          * Slider to adjust Gravity (of `mge-nodelinks`)
         */
        "_sliderGravity": any;
        /**
          * Slider to adjust linkDistance (of `mge-nodelinks`)
         */
        "_sliderLinkDistance": any;
        /**
          * Display positive value of charge attribute (of `mge-nodelinks`)
         */
        "_spanCharge": any;
        /**
          * Text span to show number of edges (of `mge-nodelinks`)
         */
        "_spanEdges": any;
        /**
          * Display the value of the attribute gravity (of `mge-nodelinks`)
         */
        "_spanGravity": any;
        /**
          * Displays the value of the linkDistance attribute (of `mge-nodelinks`)
         */
        "_spanLinkDistance": any;
        /**
          * Text span to show number of nodes (of `mge-nodelinks`)
         */
        "_spanNodes": any;
        "_spanVisibleLines": any;
        /**
          * Represents the selection of the pre-defined template based on class name of template
         */
        "filterTemplate": any;
        /**
          * id of view includes the panel
         */
        "idView": any;
        "setChart": (_: any) => Promise<void>;
        /**
          * type of visualization technique that is displayed in the same view as the setting panel
         */
        "typeVis": any;
        "updateClusterVisPanel": () => Promise<void>;
        "updateGlyphMatrixPanel": () => Promise<void>;
        "updateNodePanel": () => Promise<void>;
    }
    interface MgeQuery {
        /**
          * represents the current dashboard
         */
        "_dashboard": any;
        /**
          * represents the view includes this follow-up query
         */
        "_view": any;
        /**
          * Clone function will be call to create a new clone component This function will be run after click clone button
         */
        "cloneQuery": () => Promise<void>;
        "cloneStatus": { isClone: boolean; isFirstTime: boolean; };
        "data": any[];
        "displayGraphics": () => Promise<void>;
        "form": any;
        /**
          * Represents the panel associated with the graphic
         */
        "globalParams": any;
        "height": number;
        /**
          * List of predifined queries
         */
        "queriesList": any;
        /**
          * represents the current selected query
         */
        "query": any;
        /**
          * Set box size for the chart includes the content input is a object includes height and width
         */
        "setBox": (box: any) => Promise<void>;
        /**
          * Set type of follow-up query to clone follow-up query It will update value in cloneStatus of element
         */
        "setClone": () => Promise<void>;
        /**
          * With clone follow-up query, this function will be clone all of data from parent element variable isFirstTime of cloneStatus of this element will be changed to false after cloning data
         */
        "setCloneData": (query: any) => Promise<void>;
        /**
          * This function is to set the data to the selected data from parent  If no arguments, It will return the value of data
         */
        "setData": (_: any, oldData: any) => Promise<any[]>;
        /**
          * With initial query, this function will be set variable isInitial to true This way will help to distinguish the initial point or a follow-up query
         */
        "setInitial": () => Promise<void>;
        "width": number;
    }
    interface MgeView {
        /**
          * Title bar height
         */
        "_barTitleHeight": number;
        /**
          * View center point
         */
        "_center": { cx: number; cy: number; };
        /**
          * Chart associated with view
         */
        "_chart": any;
        /**
          * Div that represents the content includes chart of a view
         */
        "_content": any;
        /**
          * View dimensions
         */
        "_dimView": { width: number; height: number; };
        /**
          * Div that represents the filter panel of a view
         */
        "_filter": any;
        /**
          * View current position
         */
        "_position": { x: number; y: number; };
        /**
          * Refresh bar title width when we resize the windown
         */
        "_refreshBarTitle": () => Promise<void>;
        /**
          * This function allows to create a new view from current view. After create a new view , it will be added to the dashboard with a generated title view: information on view to be created (from state)
         */
        "_showChart": (node: any, parentId: any, view: any, isFromEdge?: boolean, secondNode?: any, isFromCluster?: boolean, isFromHC?: boolean) => Promise<any>;
        /**
          * Div that represents the header part of a view
         */
        "_top": any;
        /**
          * The dataset name being used
         */
        "datasetName": string;
        /**
          * Get current center position of the view
         */
        "getCenter": () => Promise<{ cx: number; cy: number; }>;
        /**
          * Get the selection of the visualization technique element which containing in this view
         */
        "getChart": () => Promise<any>;
        /**
          * Get current position of the view
         */
        "getPosition": () => Promise<{ x: number; y: number; }>;
        /**
          * represents the height of the view displayed by the window
         */
        "height": number;
        /**
          * Get ID of the view
         */
        "idChart": () => Promise<string>;
        /**
          * Id of dashboard which is containing this view
         */
        "idDash": string;
        /**
          * represents ID of the view
         */
        "idView": string;
        /**
          * this function allows to Refresh position of the view
         */
        "refresh": () => Promise<void>;
        /**
          * Set new center point for the view Inputs are coordinates (x and y) of new center position
         */
        "setCenter": (x: any, y: any) => Promise<void>;
        "setDatasetName": (value: any) => Promise<void>;
        /**
          * Set new position for the view Inputs are coordinates : x and y
         */
        "setPosition": (x: any, y: any) => Promise<void>;
        /**
          * This function allows to set new title for the view
         */
        "setTitle": (_: any) => Promise<void>;
        /**
          * Set visible for all contents in view if input status is true, the content wil be visible if input status is false, the content will be hidden
         */
        "setVisible": (status: any) => Promise<void>;
        /**
          * The title of the view
         */
        "titleView": string;
        /**
          * represents type of visualization technique displayed via content of the view
         */
        "typeVis": string;
        /**
          * Div that represents the view included
         */
        "viewDiv": any;
        /**
          * represents the width of the view displayed by the window
         */
        "width": number;
        /**
          * x-coordinate (The horizontal value in a pair of coordinates) of view's position
         */
        "x": number;
        /**
          * y-coordinate (The vertical value in a pair of coordinates) of view's position
         */
        "y": number;
    }
    interface ObjectAnnotation {
        "height": number;
        "idAnnotation": string;
        "width": number;
    }
    interface QueryAnnotation {
        "height": number;
        "width": number;
    }
    interface ViewAnnotation {
        "_annotation": any;
        "_dashboard": any;
        "height": number;
        "idAnnotation": string;
        "width": number;
    }
}
declare global {
    interface HTMLDashboardAnnotationElement extends Components.DashboardAnnotation, HTMLStencilElement {
    }
    var HTMLDashboardAnnotationElement: {
        prototype: HTMLDashboardAnnotationElement;
        new (): HTMLDashboardAnnotationElement;
    };
    interface HTMLMgeAnnotationElement extends Components.MgeAnnotation, HTMLStencilElement {
    }
    var HTMLMgeAnnotationElement: {
        prototype: HTMLMgeAnnotationElement;
        new (): HTMLMgeAnnotationElement;
    };
    interface HTMLMgeBarchartElement extends Components.MgeBarchart, HTMLStencilElement {
    }
    var HTMLMgeBarchartElement: {
        prototype: HTMLMgeBarchartElement;
        new (): HTMLMgeBarchartElement;
    };
    interface HTMLMgeClustervisElement extends Components.MgeClustervis, HTMLStencilElement {
    }
    var HTMLMgeClustervisElement: {
        prototype: HTMLMgeClustervisElement;
        new (): HTMLMgeClustervisElement;
    };
    interface HTMLMgeDashboardElement extends Components.MgeDashboard, HTMLStencilElement {
    }
    var HTMLMgeDashboardElement: {
        prototype: HTMLMgeDashboardElement;
        new (): HTMLMgeDashboardElement;
    };
    interface HTMLMgeGlyphMatrixElement extends Components.MgeGlyphMatrix, HTMLStencilElement {
    }
    var HTMLMgeGlyphMatrixElement: {
        prototype: HTMLMgeGlyphMatrixElement;
        new (): HTMLMgeGlyphMatrixElement;
    };
    interface HTMLMgeHeaderElement extends Components.MgeHeader, HTMLStencilElement {
    }
    var HTMLMgeHeaderElement: {
        prototype: HTMLMgeHeaderElement;
        new (): HTMLMgeHeaderElement;
    };
    interface HTMLMgeHistoryElement extends Components.MgeHistory, HTMLStencilElement {
    }
    var HTMLMgeHistoryElement: {
        prototype: HTMLMgeHistoryElement;
        new (): HTMLMgeHistoryElement;
    };
    interface HTMLMgeIrisElement extends Components.MgeIris, HTMLStencilElement {
    }
    var HTMLMgeIrisElement: {
        prototype: HTMLMgeIrisElement;
        new (): HTMLMgeIrisElement;
    };
    interface HTMLMgeListingElement extends Components.MgeListing, HTMLStencilElement {
    }
    var HTMLMgeListingElement: {
        prototype: HTMLMgeListingElement;
        new (): HTMLMgeListingElement;
    };
    interface HTMLMgeNodelinkElement extends Components.MgeNodelink, HTMLStencilElement {
    }
    var HTMLMgeNodelinkElement: {
        prototype: HTMLMgeNodelinkElement;
        new (): HTMLMgeNodelinkElement;
    };
    interface HTMLMgePanelElement extends Components.MgePanel, HTMLStencilElement {
    }
    var HTMLMgePanelElement: {
        prototype: HTMLMgePanelElement;
        new (): HTMLMgePanelElement;
    };
    interface HTMLMgeQueryElement extends Components.MgeQuery, HTMLStencilElement {
    }
    var HTMLMgeQueryElement: {
        prototype: HTMLMgeQueryElement;
        new (): HTMLMgeQueryElement;
    };
    interface HTMLMgeViewElement extends Components.MgeView, HTMLStencilElement {
    }
    var HTMLMgeViewElement: {
        prototype: HTMLMgeViewElement;
        new (): HTMLMgeViewElement;
    };
    interface HTMLObjectAnnotationElement extends Components.ObjectAnnotation, HTMLStencilElement {
    }
    var HTMLObjectAnnotationElement: {
        prototype: HTMLObjectAnnotationElement;
        new (): HTMLObjectAnnotationElement;
    };
    interface HTMLQueryAnnotationElement extends Components.QueryAnnotation, HTMLStencilElement {
    }
    var HTMLQueryAnnotationElement: {
        prototype: HTMLQueryAnnotationElement;
        new (): HTMLQueryAnnotationElement;
    };
    interface HTMLViewAnnotationElement extends Components.ViewAnnotation, HTMLStencilElement {
    }
    var HTMLViewAnnotationElement: {
        prototype: HTMLViewAnnotationElement;
        new (): HTMLViewAnnotationElement;
    };
    interface HTMLElementTagNameMap {
        "dashboard-annotation": HTMLDashboardAnnotationElement;
        "mge-annotation": HTMLMgeAnnotationElement;
        "mge-barchart": HTMLMgeBarchartElement;
        "mge-clustervis": HTMLMgeClustervisElement;
        "mge-dashboard": HTMLMgeDashboardElement;
        "mge-glyph-matrix": HTMLMgeGlyphMatrixElement;
        "mge-header": HTMLMgeHeaderElement;
        "mge-history": HTMLMgeHistoryElement;
        "mge-iris": HTMLMgeIrisElement;
        "mge-listing": HTMLMgeListingElement;
        "mge-nodelink": HTMLMgeNodelinkElement;
        "mge-panel": HTMLMgePanelElement;
        "mge-query": HTMLMgeQueryElement;
        "mge-view": HTMLMgeViewElement;
        "object-annotation": HTMLObjectAnnotationElement;
        "query-annotation": HTMLQueryAnnotationElement;
        "view-annotation": HTMLViewAnnotationElement;
    }
}
declare namespace LocalJSX {
    interface DashboardAnnotation {
        "height"?: number;
        "width"?: number;
    }
    interface MgeAnnotation {
        /**
          * The parent dashboard
         */
        "_dashboard"?: any;
        "_view"?: any;
        "disabled"?: boolean;
        "formAnnotation"?: any;
        "height"?: number;
        "idannotation"?: any;
        "initComponent"?: string;
        "parents"?: any[];
        "width"?: number;
    }
    interface MgeBarchart {
        /**
          * represents the panel associated with the graph
         */
        "_barPanel"?: any;
        /**
          * Contains the indexes of the attributes that can be configured in the graph
         */
        "_cfgIndexAttr"?: any;
        /**
          * colors for the different types
         */
        "_colorsBars"?: any;
        /**
          * keeps data on the different types of documents (attributes)
         */
        "_documentTypes"?: any;
        /**
          * Group representing Histogram
         */
        "_grpHistogram"?: any;
        /**
          * keeps the count of documents per year and type
         */
        "_histogramData"?: any;
        /**
          * (calculated) radius of the circle where the centroid is inserted
         */
        "_innerRadius"?: any;
        /**
          * (calculated) distance occupied by the bars
         */
        "_maxHeightBar"?: any;
        /**
          * Number of types of documents in the base
         */
        "_nbOfTypesDoc"?: any;
        /**
          * (calculated) Outernal circle radius where the graph is drawn
         */
        "_outerRadius"?: any;
        /**
          * Indirect ordering vector
         */
        "_vOrder"?: any;
        /**
          * The dataset name being used
         */
        "datasetName"?: string;
        /**
          * represents the height of the Histogram chart
         */
        "height"?: number;
        /**
          * represents the width of the Histogram chart
         */
        "width"?: number;
    }
    interface MgeClustervis {
        /**
          * Represents the panel associated with the graphic
         */
        "_clusterVisPanel"?: any;
        /**
          * Generator of splines that makes up the edges
         */
        "_drawLine"?: any;
        /**
          * Selection that contains all groups that store the bars
         */
        "_grpBars"?: any;
        /**
          * Group representing ClusterVis
         */
        "_grpCluster"?: any;
        /**
          * Selection that contains all groups that store the links
         */
        "_grpLinks"?: any;
        /**
          * Selection that contains all groups that store the rings
         */
        "_grpRings"?: any;
        /**
          * (calculated) Internal circle radius where the graph is drawn
         */
        "_innerRadius"?: number;
        /**
          * Selection that contains the links
         */
        "_links"?: any;
        /**
          * (calculated) Outernal circle radius where the graph is drawn
         */
        "_outerRadius"?: number;
        /**
          * Indicates that the same scale should be used for all bars
         */
        "_sameScale"?: boolean;
        /**
          * Coordinate x of the center of the cluster
         */
        "_xClusterCenter"?: number;
        /**
          * Coordinate y of the center of the cluster
         */
        "_yClusterCenter"?: number;
        /**
          * The dataset name being used
         */
        "datasetName"?: string;
        /**
          * represents the height of the Cluster chart
         */
        "height"?: number;
        "onIdevent"?: (event: CustomEvent<any>) => void;
        "onTestevent"?: (event: CustomEvent<any>) => void;
        /**
          * represents the width of the Cluster chart
         */
        "width"?: number;
    }
    interface MgeDashboard {
        "_annotationChart"?: any;
        /**
          * Area of dashboard for interacting
         */
        "_dashboardArea"?: any;
        /**
          * Drag connection of views
         */
        "_dragConect"?: any;
        /**
          * Stores the graph that contains history
         */
        "_historyChart"?: any;
        "_historydata"?: any;
        /**
          * First view of the dashboard. It depends on the value of initComponent to define what visualization technique or initial query is the first view to be initialized with.
         */
        "_initView"?: any;
        /**
          * Stores the tree of connections between views
         */
        "_treeCharts"?: any;
        /**
          * The dataset name being used
         */
        "datasetName"?: string;
        /**
          * type of visualization which want to create in inital point
         */
        "initComponent"?: any;
        /**
          * x-coordinate (The horizontal value in a pair of coordinates) of the dashboard
         */
        "x"?: number;
        /**
          * y-coordinate (The vertical value in a pair of coordinates) of the dashboard
         */
        "y"?: number;
    }
    interface MgeGlyphMatrix {
        /**
          * Scale is used to determine the coordinates of cells and legend elements
         */
        "_cellCoordScale"?: any;
        /**
          * keeps data on the different types of documents (attributes)
         */
        "_cellGlyph"?: any;
        /**
          * Listener of legends
         */
        "_dragListenerL"?: any;
        /**
          * Listener of Matrix
         */
        "_dragListenerM"?: any;
        /**
          * Select with all groups from left side legend bar
         */
        "_grpBarsLL"?: any;
        /**
          * Select with all groups from top side legend bar
         */
        "_grpBarsTL"?: any;
        /**
          * Select with left side legend bar
         */
        "_grpLeftLegend"?: any;
        /**
          * Contains lines with cells in each line
         */
        "_grpLines"?: any;
        /**
          * Select with matrix chart
         */
        "_grpMatrix"?: any;
        /**
          * keeps data on the different types of documents (attributes)
         */
        "_grpMatrixGlyph"?: any;
        /**
          * The group represents the matrix overview
         */
        "_grpOverview"?: any;
        /**
          * Select with top side legend bar
         */
        "_grpTopLegend"?: any;
        /**
          * Left legend clipping area id
         */
        "_idClipLeft"?: any;
        /**
          * Matrix clipping area id
         */
        "_idClipMatrix"?: any;
        /**
          * Top legend clipping area id
         */
        "_idClipTop"?: any;
        /**
          * The index of the attribute will be printed in the legend (node)
         */
        "_indexAttrLegend"?: number;
        /**
          * Attribute index used for sorting
         */
        "_indexAttrSort"?: number;
        /**
          * Group represents the entire chart
         */
        "_matrixGlyphPanel"?: any;
        /**
          * Matrix area height (calculated)
         */
        "_matrixHeight"?: number;
        /**
          * Matrix area width (calculated)
         */
        "_matrixWidth"?: number;
        /**
          * Scale is used to set the coordinates of the overview cursor
         */
        "_overviewScale"?: any;
        /**
          * Indirect ordering vector
         */
        "_vOrder"?: any;
        /**
          * The dataset name being used
         */
        "datasetName"?: string;
        /**
          * represents the height of the matrix chart
         */
        "height"?: number;
        "onIdevent"?: (event: CustomEvent<any>) => void;
        "onTestevent"?: (event: CustomEvent<any>) => void;
        /**
          * represents the width of the matrix chart
         */
        "width"?: number;
    }
    interface MgeHeader {
        "data"?: any[];
        "height"?: number;
        "width"?: number;
    }
    interface MgeHistory {
        /**
          * The parent dashboard
         */
        "_dashboard"?: any;
        /**
          * Group representing history tree
         */
        "_grpHistory"?: any;
        /**
          * Group representing nodes in the tree
         */
        "_grpNodes"?: any;
        "_historydata"?: any[];
        "_htdata"?: any;
        /**
          * Distance from the text to the left coordinate of the node
         */
        "_leftText"?: number;
        /**
          * Margin css of the node
         */
        "_nodeMargin"?: number;
        /**
          * Space height for each node without the margins
         */
        "_nodoHeight"?: number;
        /**
          * The height symbol
         */
        "_rectHeight"?: number;
        /**
          * The tree layout to stored tree data
         */
        "_treeLayout"?: any;
        /**
          * Vector with objects of all nodes
         */
        "_vNodes"?: any[];
        /**
          * represents the height of the history panel
         */
        "height"?: number;
        /**
          * Represents the panel associated with the graphic
         */
        "historyTreePanel"?: any;
        "typeVis"?: string;
        /**
          * represents the width of the history panel
         */
        "width"?: number;
    }
    interface MgeIris {
        /**
          * Contains the indexes of the attributes that can be configured in the graph
         */
        "_cfgIndexAttr"?: any;
        /**
          * colors for the different types
         */
        "_colorsBars"?: any;
        /**
          * Vector of visible data. Points to the elements of model.data
         */
        "_dataVis"?: any;
        /**
          * Contains the attribute of the fish eye area
         */
        "_fishEyeArea"?: any;
        /**
          * Contains the attribute of the focused area
         */
        "_focusArea"?: any;
        /**
          * Selection that contains all groups of bars
         */
        "_grpBars"?: any;
        /**
          * Group representing IRIS
         */
        "_grpIris"?: any;
        /**
          * Contains the attribute of the hidden area
         */
        "_hiddenArea"?: any;
        /**
          * Index in the "dataVis" vector where the first element of the data vector is located
         */
        "_indexFirstData"?: any;
        /**
          * (calculated) radius of the circle where the centroid is inserted
         */
        "_innerRadius"?: any;
        /**
          * The dataset name being used
         */
        "_irisPanel"?: any;
        /**
          * (calculated) distance occupied by the bars
         */
        "_maxHeightBar"?: any;
        /**
          * Contains the attribute of the minimum area
         */
        "_minArea"?: any;
        /**
          * number of types of documents in the base
         */
        "_nbOfTypesDoc"?: any;
        /**
          * Maximum number of the bars
         */
        "_numMaxBars"?: any;
        /**
          * Total number of the bars
         */
        "_numTotalBars"?: any;
        /**
          * The orders of typesDocs
         */
        "_orders"?: any;
        /**
          * (calculated) Outernal circle radius where the graph is drawn
         */
        "_outerRadius"?: any;
        /**
          * Percentage of center displacement
         */
        "_pDesloc"?: any;
        /**
          * Indirect ordering vector
         */
        "_vOrder"?: any;
        /**
          * The dataset name being used
         */
        "datasetName"?: string;
        /**
          * represents the height of the Iris chart
         */
        "height"?: number;
        /**
          * represents the width of the Iris chart
         */
        "width"?: number;
    }
    interface MgeListing {
        /**
          * Colors for the different types
         */
        "_colorsRect"?: any;
        /**
          * List of items in the data
         */
        "_data"?: any;
        /**
          * Selection that contains all groups of bars
         */
        "_grpPapers"?: any;
        /**
          * Group representing IRIS
         */
        "_grpPapersList"?: any;
        /**
          * Maximum length of title
         */
        "_maxLenghtTitleIndex"?: number;
        /**
          * Maximum length of names
         */
        "_maxNamesLenght"?: number;
        /**
          * Selection that contains the names of the members of a cluster
         */
        "_names"?: any;
        /**
          * represents the panel associated with the graph
         */
        "_papersListPanel"?: any;
        /**
          * The dataset name being used
         */
        "datasetName"?: string;
        /**
          * represents the height of the paper's list chart
         */
        "height"?: number;
        "onIdevent"?: (event: CustomEvent<any>) => void;
        "onTestevent"?: (event: CustomEvent<any>) => void;
        /**
          * represents the width of the paper's list chart
         */
        "width"?: number;
    }
    interface MgeNodelink {
        /**
          * The group represents the entire graphic
         */
        "_grpNodeEdge"?: any;
        /**
          * Represents the legend associated with the graphic
         */
        "_nodeEdgeLegend"?: any;
        /**
          * Represents the panel associated with the graphic
         */
        "_nodeEdgePanel"?: any;
        "_view"?: any;
        /**
          * The dataset name being used
         */
        "datasetName"?: string;
        /**
          * represents the height of the nodelinks chart
         */
        "height"?: number;
        /**
          * Action to send id of view
         */
        "onIdevent"?: (event: CustomEvent<any>) => void;
        /**
          * Action to send data to object annotation
         */
        "onTestevent"?: (event: CustomEvent<any>) => void;
        /**
          * represents the width of the nodelinks chart
         */
        "width"?: number;
    }
    interface MgePanel {
        /**
          * Represents the visualization technique which have same view with this setting panel
         */
        "_chart"?: any;
        "_divSlider"?: any;
        /**
          * Represents the div includes cloned html from template
         */
        "_filter"?: any;
        /**
          * ID of the panel that generated from id of view
         */
        "_idPanel"?: any;
        /**
          * Text search input (of `mge-nodelinks`)
         */
        "_searchAutocomplete"?: any;
        "_selectLegend"?: any;
        "_selectNodeSize"?: any;
        /**
          * Represents the select input for order of Iris(`mge-iris`) setting panel and  histogram(mge-barchart) setting panel
         */
        "_selectOrder"?: any;
        /**
          * Slider to adjust linkDistance (of `mge-nodelinks`)
         */
        "_sliderCharge"?: any;
        /**
          * Slider to adjust Gravity (of `mge-nodelinks`)
         */
        "_sliderGravity"?: any;
        /**
          * Slider to adjust linkDistance (of `mge-nodelinks`)
         */
        "_sliderLinkDistance"?: any;
        /**
          * Display positive value of charge attribute (of `mge-nodelinks`)
         */
        "_spanCharge"?: any;
        /**
          * Text span to show number of edges (of `mge-nodelinks`)
         */
        "_spanEdges"?: any;
        /**
          * Display the value of the attribute gravity (of `mge-nodelinks`)
         */
        "_spanGravity"?: any;
        /**
          * Displays the value of the linkDistance attribute (of `mge-nodelinks`)
         */
        "_spanLinkDistance"?: any;
        /**
          * Text span to show number of nodes (of `mge-nodelinks`)
         */
        "_spanNodes"?: any;
        "_spanVisibleLines"?: any;
        /**
          * Represents the selection of the pre-defined template based on class name of template
         */
        "filterTemplate"?: any;
        /**
          * id of view includes the panel
         */
        "idView"?: any;
        /**
          * type of visualization technique that is displayed in the same view as the setting panel
         */
        "typeVis"?: any;
    }
    interface MgeQuery {
        /**
          * represents the current dashboard
         */
        "_dashboard"?: any;
        /**
          * represents the view includes this follow-up query
         */
        "_view"?: any;
        "cloneStatus"?: { isClone: boolean; isFirstTime: boolean; };
        "data"?: any[];
        "form"?: any;
        /**
          * Represents the panel associated with the graphic
         */
        "globalParams"?: any;
        "height"?: number;
        /**
          * List of predifined queries
         */
        "queriesList"?: any;
        /**
          * represents the current selected query
         */
        "query"?: any;
        "width"?: number;
    }
    interface MgeView {
        /**
          * Title bar height
         */
        "_barTitleHeight"?: number;
        /**
          * View center point
         */
        "_center"?: { cx: number; cy: number; };
        /**
          * Chart associated with view
         */
        "_chart"?: any;
        /**
          * Div that represents the content includes chart of a view
         */
        "_content"?: any;
        /**
          * View dimensions
         */
        "_dimView"?: { width: number; height: number; };
        /**
          * Div that represents the filter panel of a view
         */
        "_filter"?: any;
        /**
          * View current position
         */
        "_position"?: { x: number; y: number; };
        /**
          * Div that represents the header part of a view
         */
        "_top"?: any;
        /**
          * The dataset name being used
         */
        "datasetName"?: string;
        /**
          * represents the height of the view displayed by the window
         */
        "height"?: number;
        /**
          * Id of dashboard which is containing this view
         */
        "idDash"?: string;
        /**
          * represents ID of the view
         */
        "idView"?: string;
        /**
          * The title of the view
         */
        "titleView"?: string;
        /**
          * represents type of visualization technique displayed via content of the view
         */
        "typeVis"?: string;
        /**
          * Div that represents the view included
         */
        "viewDiv"?: any;
        /**
          * represents the width of the view displayed by the window
         */
        "width"?: number;
        /**
          * x-coordinate (The horizontal value in a pair of coordinates) of view's position
         */
        "x"?: number;
        /**
          * y-coordinate (The vertical value in a pair of coordinates) of view's position
         */
        "y"?: number;
    }
    interface ObjectAnnotation {
        "height"?: number;
        "idAnnotation"?: string;
        "width"?: number;
    }
    interface QueryAnnotation {
        "height"?: number;
        "width"?: number;
    }
    interface ViewAnnotation {
        "_annotation"?: any;
        "_dashboard"?: any;
        "height"?: number;
        "idAnnotation"?: string;
        "width"?: number;
    }
    interface IntrinsicElements {
        "dashboard-annotation": DashboardAnnotation;
        "mge-annotation": MgeAnnotation;
        "mge-barchart": MgeBarchart;
        "mge-clustervis": MgeClustervis;
        "mge-dashboard": MgeDashboard;
        "mge-glyph-matrix": MgeGlyphMatrix;
        "mge-header": MgeHeader;
        "mge-history": MgeHistory;
        "mge-iris": MgeIris;
        "mge-listing": MgeListing;
        "mge-nodelink": MgeNodelink;
        "mge-panel": MgePanel;
        "mge-query": MgeQuery;
        "mge-view": MgeView;
        "object-annotation": ObjectAnnotation;
        "query-annotation": QueryAnnotation;
        "view-annotation": ViewAnnotation;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "dashboard-annotation": LocalJSX.DashboardAnnotation & JSXBase.HTMLAttributes<HTMLDashboardAnnotationElement>;
            "mge-annotation": LocalJSX.MgeAnnotation & JSXBase.HTMLAttributes<HTMLMgeAnnotationElement>;
            "mge-barchart": LocalJSX.MgeBarchart & JSXBase.HTMLAttributes<HTMLMgeBarchartElement>;
            "mge-clustervis": LocalJSX.MgeClustervis & JSXBase.HTMLAttributes<HTMLMgeClustervisElement>;
            "mge-dashboard": LocalJSX.MgeDashboard & JSXBase.HTMLAttributes<HTMLMgeDashboardElement>;
            "mge-glyph-matrix": LocalJSX.MgeGlyphMatrix & JSXBase.HTMLAttributes<HTMLMgeGlyphMatrixElement>;
            "mge-header": LocalJSX.MgeHeader & JSXBase.HTMLAttributes<HTMLMgeHeaderElement>;
            "mge-history": LocalJSX.MgeHistory & JSXBase.HTMLAttributes<HTMLMgeHistoryElement>;
            "mge-iris": LocalJSX.MgeIris & JSXBase.HTMLAttributes<HTMLMgeIrisElement>;
            "mge-listing": LocalJSX.MgeListing & JSXBase.HTMLAttributes<HTMLMgeListingElement>;
            "mge-nodelink": LocalJSX.MgeNodelink & JSXBase.HTMLAttributes<HTMLMgeNodelinkElement>;
            "mge-panel": LocalJSX.MgePanel & JSXBase.HTMLAttributes<HTMLMgePanelElement>;
            "mge-query": LocalJSX.MgeQuery & JSXBase.HTMLAttributes<HTMLMgeQueryElement>;
            "mge-view": LocalJSX.MgeView & JSXBase.HTMLAttributes<HTMLMgeViewElement>;
            "object-annotation": LocalJSX.ObjectAnnotation & JSXBase.HTMLAttributes<HTMLObjectAnnotationElement>;
            "query-annotation": LocalJSX.QueryAnnotation & JSXBase.HTMLAttributes<HTMLQueryAnnotationElement>;
            "view-annotation": LocalJSX.ViewAnnotation & JSXBase.HTMLAttributes<HTMLViewAnnotationElement>;
        }
    }
}
